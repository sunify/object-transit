{"version":3,"sources":["node_modules/run-with-fps/index.js","node_modules/tweeen/src/index.js","node_modules/rgb-hex/index.js","node_modules/hex-rgb/index.js","src/colors.ts","src/types.ts","src/utils.ts","src/index.ts","demo.js"],"names":["module","exports","red","green","blue","alpha","isPercent","toString","includes","res","match","map","Number","undefined","parseFloat","TypeError","Math","round","slice","hexChars","match3or4Hex","match6or8Hex","nonHexChars","RegExp","validHexSize","hex","options","test","replace","length","parseInt","substring","repeat","num","format","obj","document","getElementById","jsonInput","colorsInput","colorsSubmit","resultInput","gradient","applyStyle","style","transform","left","scale","color","background","bg1","bg2","innerText","count","value","JSON","stringify","initial","parse","blockStyle","console","log","transitOptions","duration","fps","easing","t","prevValue","gradientDemo","colors","curColor","stopped","gradColors","c1","c2","backgroundImage","updateColors","nextColor","to","end","stop","addEventListener","currGradientDemo","trim","split","s"],"mappings":";AAAA,OAAA,QAAA,SAAA,EAAA,GACA,IAAA,EAAA,IAAA,EACA,EAAA,KAAA,MACA,GAAA,EAmBA,OAHA,sBAdA,SAAA,IACA,GACA,sBAAA,GAGA,IAAA,EAAA,KAAA,MACA,EAAA,EAAA,EAEA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,EACA,EAAA,MAKA,EAAA,KAAA,OAEA,WACA,GAAA;;ACvBA,IAAA,EAAA,QAAA,gBAEA,SAAA,EAAA,GACA,OAAA,EAGA,SAAA,EAAA,EAAA,EAAA,EAAA,GAEA,IAAA,GADA,EAAA,GAAA,IACA,UAAA,IACA,EAAA,EAAA,QAAA,EACA,EAAA,EAAA,KAAA,GACA,EAAA,EAAA,IAEA,GAAA,EACA,EAAA,KAAA,MAEA,EAAA,EAAA,WACA,IAAA,EAAA,KAAA,IAAA,KAAA,MAAA,EAAA,GACA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,KACA,IAAA,GAAA,KACA,IACA,mBAAA,GACA,MAGA,GAEA,OAAA,WACA,GAAA,GAIA,OAAA,QAAA;;AChCA,aAEAA,OAAOC,QAAU,EAACC,EAAKC,EAAOC,EAAMC,KAC7BC,MAAAA,GAAaJ,GAAOG,GAAS,KAAKE,WAAWC,SAAS,KAExD,GAAe,iBAARN,EAAkB,CACtBO,MAAAA,EAAMP,EAAIQ,MAAM,uBAAuBC,IAAIC,QAEjDV,EAAMO,EAAI,GACVN,EAAQM,EAAI,GACZL,EAAOK,EAAI,GACXJ,EAAQI,EAAI,aACQI,IAAVR,IACVA,EAAQS,WAAWT,IAGhB,GAAe,iBAARH,GACO,iBAAVC,GACS,iBAATC,GACPF,EAAM,KACNC,EAAQ,KACRC,EAAO,IACD,MAAA,IAAIW,UAAU,oCAGjB,GAAiB,iBAAVV,EAAoB,CAC1B,IAACC,GAAaD,GAAS,GAAKA,GAAS,EACxCA,EAAQW,KAAKC,MAAM,IAAMZ,OACnB,CAAA,KAAIC,GAAaD,GAAS,GAAKA,GAAS,KAGxC,MAAA,IAAIU,UAAmCV,yBAAAA,OAAAA,EAA7C,kCAFAA,EAAQW,KAAKC,MAAM,IAAMZ,EAAQ,KAIlCA,GAAiB,IAARA,GAAgBE,SAAS,IAAIW,MAAM,QAE5Cb,EAAQ,GAGF,OAAED,EAAOD,GAAS,EAAID,GAAO,GAAM,GAAK,IAAIK,SAAS,IAAIW,MAAM,GAAKb;;ACtC5E,aAEA,IAAMc,EAAW,SACXC,EAAqBD,MAAAA,OAAAA,EAAgBA,SAAAA,OAAAA,EAA3C,MACME,EAAqBF,MAAAA,OAAAA,EAAiBA,UAAAA,OAAAA,EAA5C,UAEMG,EAAc,IAAIC,OAAaJ,MAAAA,OAAAA,EAAa,KAAA,MAC5CK,EAAe,IAAID,OAAWH,IAAAA,OAAAA,EAAkBC,OAAAA,OAAAA,EAAiB,KAAA,KAEvErB,OAAOC,QAAU,SAAUwB,GAAKC,IAAAA,EAAU,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,GACrC,GAAe,iBAARD,GAAoBH,EAAYK,KAAKF,KAASD,EAAaG,KAAKF,GACpE,MAAA,IAAIV,UAAU,+BAIjBV,IAAAA,EAAQ,IAEO,KAHnBoB,EAAMA,EAAIG,QAAQ,KAAM,KAGhBC,SACPxB,EAAQyB,SAASL,EAAIP,MAAM,EAAG,GAAI,IAAM,IACxCO,EAAMA,EAAIM,UAAU,EAAG,IAGL,IAAfN,EAAII,SACPxB,EAAQyB,SAASL,EAAIP,MAAM,EAAG,GAAGc,OAAO,GAAI,IAAM,IAClDP,EAAMA,EAAIM,UAAU,EAAG,IAGL,IAAfN,EAAII,SACPJ,EAAMA,EAAI,GAAKA,EAAI,GAAKA,EAAI,GAAKA,EAAI,GAAKA,EAAI,GAAKA,EAAI,IAGlDQ,IAAAA,EAAMH,SAASL,EAAK,IACpBvB,EAAM+B,GAAO,GACb9B,EAAS8B,GAAO,EAAK,IACrB7B,EAAa,IAAN6B,EAENP,MAAmB,UAAnBA,EAAQQ,OACd,CAAChC,EAAKC,EAAOC,EAAMC,GACnB,CAACH,IAAAA,EAAKC,MAAAA,EAAOC,KAAAA,EAAMC,MAAAA;;ACoBR,aAAA,IAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA1Db,IAAA,EAAA,EAAA,QAAA,YACA,EAAA,EAAA,QAAA,YACA,EAAA,QAAA,WAEM,EAAgB,8CAChB,EAAgB,qDAChB,EAAiB,kFAEV,QAAA,QAAU,SAAC,GACtB,OAAA,EAAc,KAAK,OAAO,KAC1B,EAAc,KAAK,OAAO,KAC1B,EAAe,KAAK,OAAO,KAEhB,QAAA,WAAa,SAAC,GACrB,GAAA,EAAc,KAAK,GAAQ,CACvB,IAAA,EAAA,EAAA,QAAA,EAAA,CAAA,OAAA,UAAC,EAAA,EAAA,GAAG,EAAA,EAAA,GAAG,EAAA,EAAA,GAAG,EAAA,EAAA,GACT,MAAA,CAAC,EAAG,EAAG,EAAS,MAAN,EAAY,EAAI,GAI3B,IAUA,EAXJ,GAAA,EAAc,KAAK,KACf,EAAQ,EAAM,MAAM,IAEjB,OAAA,EACJ,MAAM,EAAG,GACT,IAAI,QACJ,OAAO,CAAC,IAIX,GAAA,EAAe,KAAK,KAChB,EAAQ,EAAM,MAAM,IAEjB,OAAA,EAAM,MAAM,EAAG,GAAG,IAAI,SAOtB,QAAA,eAAiB,SAAC,EAAiB,GACxC,IAAA,EAAA,EAAA,MAAA,EAAA,GAAA,IAAA,KAAA,OAAC,EAAA,EAAA,GAAG,EAAA,EAAA,GAAG,EAAA,EAAA,GACP,EAAI,EAAM,GAEZ,OAAA,EAAc,KAAK,GACX,IAAN,EACK,IAAI,EAAA,QAAO,EAAG,EAAG,GAGnB,IAAI,EAAA,QAAO,EAAG,EAAG,EAAG,GAGzB,EAAc,KAAK,IAAiB,IAAN,EACzB,OAAO,EAAC,KAAK,EAAC,KAAK,EAAC,IAGtB,QAAQ,EAAC,KAAK,EAAC,KAAK,EAAC,KAAK,EAAC,KAGvB,QAAA,iBAAmB,SAC9B,EACA,EACA,GAEI,GAAY,IAAZ,GAAiB,IAAU,EACtB,OAAA,EAGL,GAAY,IAAZ,EACK,OAAA,EAGH,IAAA,EAAa,QAAA,WAAW,GACxB,EAAW,QAAA,WAAW,GAExB,OAAA,GAAc,EACT,QAAA,eAAe,EAAA,UAAU,EAAY,EAAU,GAAU,QAD9D;;AC9CN,aAAA,IAAA,EAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA5BA,IAGY,EAHZ,EAAA,QAAA,WACA,EAAA,QAAA,aAEA,SAAY,GACV,EAAA,EAAA,OAAA,GAAA,SACA,EAAA,EAAA,MAAA,GAAA,QAFF,CAAY,EAAA,QAAA,QAAA,QAAA,MAAK,KAUjB,IAAM,IAAK,EAAA,IACR,EAAM,QAAS,CACd,KAAM,SAAC,GAAW,MAAa,iBAAN,GACzB,YAAa,EAAA,MAEf,EAAC,EAAM,OAAQ,CACb,KAAM,EAAA,QACN,YAAa,EAAA,kBAPN,GAWE,QAAA,aAAe,SAAC,GACpB,OAAA,EAAA,KAAK,GAAO,KAAK,SAAA,GAAO,OAAA,EAAM,GAAK,KAAK,MAGjD,QAAA,QAAe;;ACqBF,aAAA,IAAA,EAAA,MAAA,KAAA,cAAA,SAAA,GAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,IAAA,EAAA,GAAA,GAAA,MAAA,EAAA,IAAA,IAAA,KAAA,EAAA,OAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,EAAA,QAAA,EAAA,GAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAjDb,IAAA,EAAA,EAAA,QAAA,YAIA,SAAgB,EAAQ,GACf,OAAA,OAAO,KAAK,GADrB,QAAA,KAAA,EAIa,QAAA,aAAe,SAC1B,EACA,EACA,EACA,GAEM,IAAA,EAAa,EAAK,GAAQ,OAC9B,SAAA,GAAO,YAA8B,IAA9B,EAAA,aAAa,EAAO,MAEvB,EAAQ,GAEd,EAAW,QAAQ,SAAA,GACX,IAAA,EAAO,EAAA,aAAa,EAAO,IAC7B,IACF,EAAM,GAAO,EAAA,QAAM,GAAM,YACvB,EAAO,GACP,EAAO,GACP,MAIN,OAAO,OAAO,EAAO,IAGV,QAAA,aAAe,SAAI,EAAkB,GAChD,EAAK,GACF,OAAO,SAAA,GAAO,YAA8B,IAA9B,EAAA,aAAa,EAAO,MAClC,OAAO,SAAA,GAAO,YAA6B,IAA7B,EAAA,aAAa,EAAM,MACjC,QAAQ,SAAA,GACP,EAAM,GAAO,EAAO,MAIb,QAAA,KAAO,SAAC,EAAe,EAAa,GAC3C,OAAA,IAAU,EACL,EAGF,GAAS,EAAM,GAAS,GAGpB,QAAA,UAAY,SAAC,EAAiB,EAAe,GACxD,OAAA,EAAM,IAAI,SAAC,EAAG,GAAM,OAAA,QAAA,KAAK,EAAG,EAAI,GAAI;;AC3CtC,aAAA,IAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAPA,IAAA,EAAA,EAAA,QAAA,WACA,EAAA,QAAA,WAMA,SAAwB,EACtB,EACA,GAEM,IACF,EADE,EAAQ,OAAO,OAAO,GAAI,GAG1B,EAAW,CACf,OAAA,SAAU,GAKD,OAJP,OAAO,OAAO,EAAO,GACH,mBAAP,GACT,EAAG,GAEE,GAET,KAAI,WACE,IACF,IACA,OAAgB,IAGpB,GAAA,SAAM,EAAW,QAAA,IAAA,IAAA,EAAA,IACT,IAAA,EAAS,OAAO,OAAO,GAAI,GAsB1B,OArBP,EAAA,aAAa,EAAO,GACf,KAAA,OAEL,EAAgB,EAAA,QACd,EACA,EACA,SAAA,GACE,EAAA,aAAa,EAAO,EAAQ,EAAQ,GAClB,mBAAP,GACT,EAAG,IAGP,OAAO,OAAO,GAAI,EAAS,CACzB,IAAK,WACwB,mBAAhB,EAAQ,KACjB,EAAQ,IAAI,OAMb,IAIL,EAAQ,IAAI,MAA2B,EAAc,CACzD,IAAG,SAAC,EAAK,GACH,OAAA,EAAI,eAAe,GACb,EAAY,GAGd,EAAiB,MAItB,OAAA,EA1DT,QAAA,QAAA;;AC0EA,aAjFA,IAAA,EAAA,EAAA,QAAA,mBAiFA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GA/EA,IAAM8B,EAAMC,SAASC,eAAe,OAC9BC,EAAYF,SAASC,eAAe,QACpCE,EAAcH,SAASC,eAAe,UACtCG,EAAeJ,SAASC,eAAe,gBACvCI,EAAcL,SAASC,eAAe,UACtCK,EAAWN,SAASC,eAAe,QAEnCM,EAAa,SAAAC,GACjBT,EAAIS,MAAMC,UAAyBD,aAAAA,OAAAA,EAAME,KACvCF,oBAAAA,OAAAA,EAAMG,MADR,KAGAZ,EAAIS,MAAMI,MAAQJ,EAAMI,OAAS,OACjCb,EAAIS,MAAMK,WAAgCL,mBAAAA,OAAAA,EAAMM,IAAQN,MAAAA,OAAAA,EAAMO,IAA9D,KACAhB,EAAIiB,UAAYpC,KAAKC,MAAM2B,EAAMS,OACjCZ,EAAYa,MAAQC,KAAKC,UAAUZ,OAAO/B,EAAW,IAGjD4C,EAAUF,KAAKG,MAAMpB,EAAUgB,OAC/BK,GAAa,EAAQF,EAAAA,SAAAA,EAASd,GACpCA,EAAWc,GACXG,QAAQC,IAAIF,GAEZ,IAAMG,EAAiB,CACrBC,SAAU,IACVC,IAAK,GACLC,OAAQ,SAAAC,GAAMA,OAAAA,EAAI,GAAM,EAAIA,EAAIA,GAAU,EAAI,EAAIA,GAAKA,EAAlB,IAGnCC,EAAY7B,EAAUgB,MAQ1B,SAASc,EAAaC,GAChBC,IAAAA,GAAY,EACZC,GAAU,EACRC,GAAa,EACjB,EAAA,SAAA,CAAEC,GAAIJ,EAAOA,EAAOxC,OAAS,GAAI6C,GAAIL,EAAO,IAC5C,SAAgB,GAAbI,IAAAA,EAAAA,EAAAA,GAAIC,EAAAA,EAAAA,GACLhC,EAASE,MAAM+B,gBAAqCF,mBAAAA,OAAAA,EAAOC,MAAAA,OAAAA,EAA3D,OAwBG,OApBc,SAAfE,IACAL,IAAAA,EAAAA,CAIEM,IAAAA,GAAwB,GAD9BP,GAAYA,EAAW,GAAKD,EAAOxC,SACAwC,EAAOxC,OAC1C2C,EAAWM,GACT,CACEL,GAAIJ,EAAOC,GACXI,GAAIL,EAAOQ,IAEb,CACEE,IAAKH,EACLb,SAAU,OAKhBa,GAEO,WACLJ,EAAWQ,OACXT,GAAU,GAvCdjC,EAAU2C,iBAAiB,QAAS,WAC9Bd,IAAc7B,EAAUgB,QAC1BK,EAAWmB,GAAGvB,KAAKG,MAAMpB,EAAUgB,OAAQQ,GAC3CK,EAAY7B,EAAUgB,SAwC1B,IAAI4B,EAAmBd,EACrB7B,EAAYe,MACT6B,OACAC,MAAM,MACNzE,IAAI,SAAA0E,GAAKA,OAAAA,EAAEF,UAGhB3C,EAAayC,iBAAiB,QAAS,WACjCC,GACFA,IAEFA,EAAmBd,EACjB7B,EAAYe,MACT6B,OACAC,MAAM,MACNzE,IAAI,SAAA0E,GAAKA,OAAAA,EAAEF","file":"demo.82fd19d8.map","sourceRoot":"..","sourcesContent":["module.exports = function runWithFPS (fn, fps) {\n  var interval = 1000 / fps;\n  var then = Date.now();\n  var stopped = false;\n\n  function run() {\n    if (!stopped) {\n      requestAnimationFrame(run);\n    }\n\n    var now = Date.now();\n    var delta = now - then;\n\n    if (delta > interval && !stopped) {\n      then = now - (delta % interval);\n      fn(now);\n    }\n  };\n\n  requestAnimationFrame(run);\n  fn(Date.now());\n\n  return function() {\n    stopped = true;\n  }\n};","var runWithFps = require('run-with-fps');\n\nfunction linear(a) {\n  return a;\n}\n\nfunction tween(from, to, cb, params) {\n  params = params || {};\n  var duration = params.duration || 300;\n  var easing = params.easing || linear;\n  var fps = params.fps || 60;\n  var end = params.end;\n\n  var stopped = false;\n  var start = Date.now();\n\n  var stop = runWithFps(function() {\n    var spent = Math.min(Date.now() - start, duration);\n    cb(from + (to - from) * easing(spent / duration));\n    if (spent === duration || stopped) {\n      stop();\n      if (typeof end === 'function') {\n        end();\n      }\n    }\n  }, fps);\n\n  return function() {\n    stopped = true;\n  };\n}\n\nmodule.exports = tween;\n","'use strict';\n/* eslint-disable no-mixed-operators */\nmodule.exports = (red, green, blue, alpha) => {\n\tconst isPercent = (red + (alpha || '')).toString().includes('%');\n\n\tif (typeof red === 'string') {\n\t\tconst res = red.match(/(0?\\.?\\d{1,3})%?\\b/g).map(Number);\n\t\t// TODO: use destructuring when targeting Node.js 6\n\t\tred = res[0];\n\t\tgreen = res[1];\n\t\tblue = res[2];\n\t\talpha = res[3];\n\t} else if (alpha !== undefined) {\n\t\talpha = parseFloat(alpha);\n\t}\n\n\tif (typeof red !== 'number' ||\n\t\ttypeof green !== 'number' ||\n\t\ttypeof blue !== 'number' ||\n\t\tred > 255 ||\n\t\tgreen > 255 ||\n\t\tblue > 255) {\n\t\tthrow new TypeError('Expected three numbers below 256');\n\t}\n\n\tif (typeof alpha === 'number') {\n\t\tif (!isPercent && alpha >= 0 && alpha <= 1) {\n\t\t\talpha = Math.round(255 * alpha);\n\t\t} else if (isPercent && alpha >= 0 && alpha <= 100) {\n\t\t\talpha = Math.round(255 * alpha / 100);\n\t\t} else {\n\t\t\tthrow new TypeError(`Expected alpha value (${alpha}) as a fraction or percentage`);\n\t\t}\n\t\talpha = (alpha | 1 << 8).toString(16).slice(1);\n\t} else {\n\t\talpha = '';\n\t}\n\n\treturn ((blue | green << 8 | red << 16) | 1 << 24).toString(16).slice(1) + alpha;\n};\n","'use strict';\n\nconst hexChars = 'a-f\\\\d';\nconst match3or4Hex = `#?[${hexChars}]{3}[${hexChars}]?`;\nconst match6or8Hex = `#?[${hexChars}]{6}([${hexChars}]{2})?`;\n\nconst nonHexChars = new RegExp(`[^#${hexChars}]`, 'gi');\nconst validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, 'i');\n\nmodule.exports = function (hex, options = {}) {\n\tif (typeof hex !== 'string' || nonHexChars.test(hex) || !validHexSize.test(hex)) {\n\t\tthrow new TypeError('Expected a valid hex string');\n\t}\n\n\thex = hex.replace(/^#/, '');\n\tlet alpha = 255;\n\n\tif (hex.length === 8) {\n\t\talpha = parseInt(hex.slice(6, 8), 16) / 255;\n\t\thex = hex.substring(0, 6);\n\t}\n\n\tif (hex.length === 4) {\n\t\talpha = parseInt(hex.slice(3, 4).repeat(2), 16) / 255;\n\t\thex = hex.substring(0, 3);\n\t}\n\n\tif (hex.length === 3) {\n\t\thex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n\t}\n\n\tconst num = parseInt(hex, 16);\n\tconst red = num >> 16;\n\tconst green = (num >> 8) & 255;\n\tconst blue = num & 255;\n\n\treturn options.format === 'array' ?\n\t\t[red, green, blue, alpha] :\n\t\t{red, green, blue, alpha};\n};\n","import rgbHex from 'rgb-hex';\nimport hexRgb from 'hex-rgb';\nimport { lerpArray } from './utils';\n\nconst hexColorRegex = /^#(?=[0-9a-fA-F]*$)(?:.{3}|.{4}|.{6}|.{8})$/;\nconst rgbColorRegex = /^rgb\\((\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\)$/;\nconst rgbaColorRegex = /^rgba\\((\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d+(?:\\.\\d+)?|\\.\\d+)\\)$/;\n\nexport const isColor = (c: any) =>\n  hexColorRegex.test(String(c)) ||\n  rgbColorRegex.test(String(c)) ||\n  rgbaColorRegex.test(String(c));\n\nexport const parseColor = (color: string) => {\n  if (hexColorRegex.test(color)) {\n    const [r, g, b, a] = hexRgb(color, { format: 'array' });\n    return [r, g, b, a === 255 ? 1 : a];\n  }\n\n  if (rgbColorRegex.test(color)) {\n    const match = color.match(rgbColorRegex);\n    if (match) {\n      return match\n        .slice(1, 4)\n        .map(Number)\n        .concat([1]);\n    }\n  }\n\n  if (rgbaColorRegex.test(color)) {\n    const match = color.match(rgbaColorRegex);\n    if (match) {\n      return match.slice(1, 5).map(Number);\n    }\n  }\n\n  return undefined;\n};\n\nexport const stringifyColor = (color: number[], target: string) => {\n  const [r, g, b] = color.slice(0, 3).map(Math.round);\n  const a = color[3];\n\n  if (hexColorRegex.test(target)) {\n    if (a === 1) {\n      return `#${rgbHex(r, g, b)}`;\n    }\n\n    return `#${rgbHex(r, g, b, a)}`;\n  }\n\n  if (rgbColorRegex.test(target) && a === 1) {\n    return `rgb(${r}, ${g}, ${b})`;\n  }\n\n  return `rgba(${r}, ${g}, ${b}, ${a})`;\n};\n\nexport const interpolateColor = (\n  start: string,\n  end: string,\n  percent: number\n) => {\n  if (percent === 0 || start === end) {\n    return start;\n  }\n\n  if (percent === 1) {\n    return end;\n  }\n\n  const startColor = parseColor(start);\n  const endColor = parseColor(end);\n\n  if (startColor && endColor) {\n    return stringifyColor(lerpArray(startColor, endColor, percent), end);\n  }\n\n  return undefined;\n};\n","import { keys, lerp } from './utils';\nimport { interpolateColor, isColor } from './colors';\n\nexport enum Types {\n  number,\n  color\n}\n\nexport type Type<P> = {\n  test: (value: unknown) => boolean;\n  interpolate: (start: P, end: P, percent: number) => P | undefined;\n};\n\nconst types = {\n  [Types.number]: {\n    test: (n: any) => typeof n === 'number',\n    interpolate: lerp\n  },\n  [Types.color]: {\n    test: isColor,\n    interpolate: interpolateColor\n  }\n};\n\nexport const getValueType = (v: any) => {\n  return keys(types).find(key => types[key].test(v));\n};\n\nexport default types;\n","import types, { getValueType } from './types';\n\ntype Target<T> = { [key in keyof T]?: T[keyof T] };\n\nexport function keys<T>(object: T): Array<keyof T> {\n  return Object.keys(object) as any;\n}\n\nexport const updateValues = <T, P>(\n  state: T,\n  source: T,\n  target: { [key in keyof T & P]?: (T & P)[keyof T & P] },\n  percent: number\n) => {\n  const targetKeys = keys(target).filter(\n    key => getValueType(target[key]) !== undefined\n  );\n  const patch = {} as T;\n\n  targetKeys.forEach(key => {\n    const type = getValueType(source[key]);\n    if (type) {\n      patch[key] = types[type].interpolate(\n        source[key] as any,\n        target[key] as any,\n        percent\n      ) as any;\n    }\n  });\n  Object.assign(state, patch);\n};\n\nexport const applyNewKeys = <T>(state: Target<T>, target: T) => {\n  keys(target)\n    .filter(key => getValueType(target[key]) !== undefined)\n    .filter(key => getValueType(state[key]) === undefined)\n    .forEach(key => {\n      state[key] = target[key];\n    });\n};\n\nexport const lerp = (start: number, end: number, percent: number) => {\n  if (start === end) {\n    return start;\n  }\n\n  return start + (end - start) * percent;\n};\n\nexport const lerpArray = (start: number[], end: number[], percent: number) =>\n  start.map((n, i) => lerp(n, end[i], percent));\n","import tweeen, { TweenParams } from 'tweeen';\nimport { updateValues, applyNewKeys } from './utils';\n\nexport type Params<T> = {\n  end?: (result: T) => void;\n} & TweenParams;\n\nexport default function transit<T extends Object>(\n  initial: T,\n  cb: (state: T) => void\n) {\n  const state = Object.assign({}, initial);\n  let currentTweeen: any;\n\n  const instance = {\n    assign<R>(target: R) {\n      Object.assign(state, target);\n      if (typeof cb === 'function') {\n        cb(state);\n      }\n      return proxy as T & R & typeof instance;\n    },\n    stop() {\n      if (currentTweeen) {\n        currentTweeen();\n        currentTweeen = undefined;\n      }\n    },\n    to<R>(target: R, options: Params<T & R> = {}) {\n      const source = Object.assign({}, state);\n      applyNewKeys(state, target);\n      this.stop();\n\n      currentTweeen = tweeen(\n        0,\n        1,\n        percent => {\n          updateValues(state, source, target, percent);\n          if (typeof cb === 'function') {\n            cb(state as T & R);\n          }\n        },\n        Object.assign({}, options, {\n          end: () => {\n            if (typeof options.end === 'function') {\n              options.end(state as T & R);\n            }\n          }\n        })\n      );\n\n      return proxy as T & R & typeof instance;\n    }\n  };\n\n  const proxy = new Proxy<T & typeof instance>(state as any, {\n    get(obj, prop) {\n      if (obj.hasOwnProperty(prop)) {\n        return (obj as any)[prop as string];\n      }\n\n      return (instance as any)[prop];\n    }\n  });\n\n  return proxy;\n}\n","import transit from './src/index.ts';\n\nconst obj = document.getElementById('obj');\nconst jsonInput = document.getElementById('json');\nconst colorsInput = document.getElementById('colors');\nconst colorsSubmit = document.getElementById('colorsSubmit');\nconst resultInput = document.getElementById('result');\nconst gradient = document.getElementById('grad');\n\nconst applyStyle = style => {\n  obj.style.transform = `translate(${style.left}px, 40px) scale(${\n    style.scale\n  })`;\n  obj.style.color = style.color || '#000';\n  obj.style.background = `linear-gradient(${style.bg1}, ${style.bg2})`;\n  obj.innerText = Math.round(style.count);\n  resultInput.value = JSON.stringify(style, undefined, 2);\n};\n\nconst initial = JSON.parse(jsonInput.value);\nconst blockStyle = transit(initial, applyStyle);\napplyStyle(initial);\nconsole.log(blockStyle);\n\nconst transitOptions = {\n  duration: 300,\n  fps: 60,\n  easing: t => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t)\n};\n\nlet prevValue = jsonInput.value;\njsonInput.addEventListener('keyup', () => {\n  if (prevValue !== jsonInput.value) {\n    blockStyle.to(JSON.parse(jsonInput.value), transitOptions);\n    prevValue = jsonInput.value;\n  }\n});\n\nfunction gradientDemo(colors) {\n  let curColor = -1;\n  let stopped = false;\n  const gradColors = transit(\n    { c1: colors[colors.length - 1], c2: colors[0] },\n    ({ c1, c2 }) => {\n      gradient.style.backgroundImage = `linear-gradient(${c1}, ${c2})`;\n    }\n  );\n\n  const updateColors = () => {\n    if (stopped) {\n      return;\n    }\n    curColor = (curColor + 1) % colors.length;\n    const nextColor = (curColor + 1) % colors.length;\n    gradColors.to(\n      {\n        c1: colors[curColor],\n        c2: colors[nextColor]\n      },\n      {\n        end: updateColors,\n        duration: 2000\n      }\n    );\n  };\n\n  updateColors();\n\n  return () => {\n    gradColors.stop();\n    stopped = true;\n  };\n}\n\nlet currGradientDemo = gradientDemo(\n  colorsInput.value\n    .trim()\n    .split('\\n')\n    .map(s => s.trim())\n);\n\ncolorsSubmit.addEventListener('click', () => {\n  if (currGradientDemo) {\n    currGradientDemo();\n  }\n  currGradientDemo = gradientDemo(\n    colorsInput.value\n      .trim()\n      .split('\\n')\n      .map(s => s.trim())\n  );\n});\n"]}