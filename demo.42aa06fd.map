{"version":3,"sources":["node_modules/run-with-fps/index.js","node_modules/tweeen/src/index.js","node_modules/rgb-hex/index.js","node_modules/hex-rgb/index.js","src/types.ts","src/utils.ts","src/index.ts","demo.js"],"names":["module","exports","red","green","blue","alpha","isPercent","toString","includes","res","match","map","Number","undefined","parseFloat","TypeError","Math","round","slice","hexChars","match3or4Hex","match6or8Hex","nonHexChars","RegExp","validHexSize","hex","options","test","replace","length","parseInt","substring","repeat","num","format","obj","document","getElementById","jsonInput","colorsInput","colorsSubmit","resultInput","gradient","applyStyle","style","transform","left","scale","color","background","bg1","bg2","innerText","count","value","JSON","stringify","initial","parse","blockStyle","console","log","transitOptions","duration","fps","easing","t","prevValue","gradientDemo","colors","curColor","stopped","gradColors","c1","c2","backgroundImage","updateColors","nextColor","to","end","stop","addEventListener","currGradientDemo","trim","split","s"],"mappings":"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","file":"demo.42aa06fd.map","sourceRoot":"..","sourcesContent":["module.exports = function runWithFPS (fn, fps) {\n  var interval = 1000 / fps;\n  var then = Date.now();\n  var stopped = false;\n\n  function run() {\n    if (!stopped) {\n      requestAnimationFrame(run);\n    }\n\n    var now = Date.now();\n    var delta = now - then;\n\n    if (delta > interval && !stopped) {\n      then = now - (delta % interval);\n      fn(now);\n    }\n  };\n\n  requestAnimationFrame(run);\n  fn(Date.now());\n\n  return function() {\n    stopped = true;\n  }\n};","var runWithFps = require('run-with-fps');\n\nfunction linear(a) {\n  return a;\n}\n\nfunction tween(from, to, cb, params) {\n  params = params || {};\n  var duration = params.duration || 300;\n  var easing = params.easing || linear;\n  var fps = params.fps || 60;\n  var end = params.end;\n\n  var stopped = false;\n  var start = Date.now();\n\n  var stop = runWithFps(function() {\n    var spent = Math.min(Date.now() - start, duration);\n    cb(from + (to - from) * easing(spent / duration));\n    if (spent === duration || stopped) {\n      stop();\n      if (typeof end === 'function') {\n        end();\n      }\n    }\n  }, fps);\n\n  return function() {\n    stopped = true;\n  };\n}\n\nmodule.exports = tween;\n","'use strict';\n/* eslint-disable no-mixed-operators */\nmodule.exports = (red, green, blue, alpha) => {\n\tconst isPercent = (red + (alpha || '')).toString().includes('%');\n\n\tif (typeof red === 'string') {\n\t\tconst res = red.match(/(0?\\.?\\d{1,3})%?\\b/g).map(Number);\n\t\t// TODO: use destructuring when targeting Node.js 6\n\t\tred = res[0];\n\t\tgreen = res[1];\n\t\tblue = res[2];\n\t\talpha = res[3];\n\t} else if (alpha !== undefined) {\n\t\talpha = parseFloat(alpha);\n\t}\n\n\tif (typeof red !== 'number' ||\n\t\ttypeof green !== 'number' ||\n\t\ttypeof blue !== 'number' ||\n\t\tred > 255 ||\n\t\tgreen > 255 ||\n\t\tblue > 255) {\n\t\tthrow new TypeError('Expected three numbers below 256');\n\t}\n\n\tif (typeof alpha === 'number') {\n\t\tif (!isPercent && alpha >= 0 && alpha <= 1) {\n\t\t\talpha = Math.round(255 * alpha);\n\t\t} else if (isPercent && alpha >= 0 && alpha <= 100) {\n\t\t\talpha = Math.round(255 * alpha / 100);\n\t\t} else {\n\t\t\tthrow new TypeError(`Expected alpha value (${alpha}) as a fraction or percentage`);\n\t\t}\n\t\talpha = (alpha | 1 << 8).toString(16).slice(1);\n\t} else {\n\t\talpha = '';\n\t}\n\n\treturn ((blue | green << 8 | red << 16) | 1 << 24).toString(16).slice(1) + alpha;\n};\n","'use strict';\n\nconst hexChars = 'a-f\\\\d';\nconst match3or4Hex = `#?[${hexChars}]{3}[${hexChars}]?`;\nconst match6or8Hex = `#?[${hexChars}]{6}([${hexChars}]{2})?`;\n\nconst nonHexChars = new RegExp(`[^#${hexChars}]`, 'gi');\nconst validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, 'i');\n\nmodule.exports = function (hex, options = {}) {\n\tif (typeof hex !== 'string' || nonHexChars.test(hex) || !validHexSize.test(hex)) {\n\t\tthrow new TypeError('Expected a valid hex string');\n\t}\n\n\thex = hex.replace(/^#/, '');\n\tlet alpha = 255;\n\n\tif (hex.length === 8) {\n\t\talpha = parseInt(hex.slice(6, 8), 16) / 255;\n\t\thex = hex.substring(0, 6);\n\t}\n\n\tif (hex.length === 4) {\n\t\talpha = parseInt(hex.slice(3, 4).repeat(2), 16) / 255;\n\t\thex = hex.substring(0, 3);\n\t}\n\n\tif (hex.length === 3) {\n\t\thex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n\t}\n\n\tconst num = parseInt(hex, 16);\n\tconst red = num >> 16;\n\tconst green = (num >> 8) & 255;\n\tconst blue = num & 255;\n\n\treturn options.format === 'array' ?\n\t\t[red, green, blue, alpha] :\n\t\t{red, green, blue, alpha};\n};\n","import rgbHex from 'rgb-hex';\nimport hexRgb from 'hex-rgb';\nimport { keys } from './utils';\n\nconst hexColorRegex = /^#(?=[0-9a-fA-F]*$)(?:.{3}|.{6})$/;\nconst rgbColorRegex = /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/;\nconst rgbaColorRegex = /^rgba\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d+(?:\\.\\d+)?)\\)$/;\n\nconst lerp = (start: number, end: number, percent: number) =>\n  start + (end - start) * percent;\nconst lerpArray = (start: number[], end: number[], percent: number) =>\n  start.map((n, i) => lerp(n, end[i], percent));\n\nexport type Interpolate<T extends number | number[]> = (\n  start: T,\n  end: T,\n  percent: number\n) => T;\nconst interpolate = <T extends number | number[]>(\n  start: T,\n  end: T,\n  percent: number\n) => {\n  if (Array.isArray(start) && Array.isArray(end)) {\n    return lerpArray(start, end, percent);\n  }\n\n  return lerp(start as number, end as number, percent);\n};\n\nexport enum Types {\n  number,\n  color\n}\n\nexport type Type<T extends number | number[], P> = {\n  test: (value: any) => boolean;\n  parse: (value: P) => T;\n  prepare: (value: T, source?: P, target?: P) => P;\n  interpolate: Interpolate<T>;\n};\n\nconst types = {\n  [Types.number]: {\n    test: (n: any) => typeof n === 'number',\n    parse: Number,\n    prepare: Number,\n    interpolate: interpolate as Interpolate<number>\n  } as Type<number, number>,\n  [Types.color]: {\n    test: (c: string) =>\n      hexColorRegex.test(c) || rgbColorRegex.test(c) || rgbaColorRegex.test(c),\n    parse: (v: string) => {\n      if (hexColorRegex.test(v)) {\n        return hexRgb(v, { format: 'array' })\n          .slice(0, 3)\n          .concat([1]);\n      }\n\n      if (rgbColorRegex.test(v)) {\n        const match = v.match(rgbColorRegex);\n        if (match) {\n          return match\n            .slice(1, 4)\n            .map(Number)\n            .concat([1]);\n        }\n      }\n\n      if (rgbaColorRegex.test(v)) {\n        const match = v.match(rgbaColorRegex);\n        if (match) {\n          return match.slice(1, 5).map(Number);\n        }\n      }\n\n      return undefined;\n    },\n    prepare: (v: number[], source, target) => {\n      const [r, g, b] = v.slice(0, 3).map(Math.round);\n      const a = v[3];\n\n      if (source && target) {\n        if (!rgbaColorRegex.test(source) && hexColorRegex.test(target)) {\n          return `#${rgbHex(r, g, b)}`;\n        }\n\n        if (!rgbaColorRegex.test(source) && rgbColorRegex.test(target)) {\n          return `rgb(${r}, ${g}, ${b})`;\n        }\n\n        if (rgbaColorRegex.test(source) && !rgbaColorRegex.test(target)) {\n          if (a === 1) {\n            if (hexColorRegex.test(target)) {\n              return `#${rgbHex(r, g, b)}`;\n            }\n\n            if (rgbColorRegex.test(target)) {\n              return `rgb(${r}, ${g}, ${b})`;\n            }\n          }\n        }\n      }\n\n      return `rgba(${r}, ${g}, ${b}, ${a})`;\n    },\n    interpolate: interpolate as Interpolate<number[]>\n  } as Type<number[], string>\n};\n\nexport const getValueType = (v: any) => {\n  return keys(types).find(key => types[key].test(v));\n};\n\nexport default types;\n","import types, { getValueType } from './types';\n\ntype Target<T> = { [key in keyof T]?: T[keyof T] };\n\nexport function keys<T>(object: T): Array<keyof T> {\n  return Object.keys(object) as any;\n}\n\nexport const updateValues = <T>(\n  state: T,\n  source: T,\n  target: Object,\n  percent: number\n) => {\n  const targetKeys = keys(target).filter(\n    key => getValueType(target[key]) !== undefined\n  );\n  const patch = {} as T;\n\n  targetKeys.forEach(key => {\n    const type = getValueType(source[key]);\n    if (type) {\n      patch[key] = types[type].prepare(\n        types[type].interpolate(\n          types[type].parse(source[key] as any),\n          types[type].parse(target[key] as any),\n          percent\n        ),\n        source[key] as any,\n        target[key] as any\n      ) as any;\n    }\n  });\n  Object.assign(state, patch);\n};\n\nexport const applyNewKeys = <T>(state: Target<T>, target: T) => {\n  keys(target)\n    .filter(key => getValueType(target[key]) !== undefined)\n    .filter(key => getValueType(state[key]) === undefined)\n    .forEach(key => {\n      state[key] = target[key];\n    });\n};\n","import tweeen, { TweenParams } from 'tweeen';\nimport { updateValues, applyNewKeys } from './utils';\n\nexport type Params<T> = {\n  end?: (result: T) => void;\n} & TweenParams;\n\nexport default function transit<T extends Object>(\n  initial: T,\n  cb: (state: T) => void\n) {\n  const state = Object.assign({}, initial);\n  let currentTweeen: any;\n\n  const instance = {\n    assign<R>(target: R) {\n      Object.assign(state, target);\n      if (typeof cb === 'function') {\n        cb(state);\n      }\n      return proxy as T & R & typeof instance;\n    },\n    stop() {\n      if (currentTweeen) {\n        currentTweeen();\n        currentTweeen = undefined;\n      }\n    },\n    to<R>(target: R, options: Params<T & R> = {}) {\n      const source = Object.assign({}, state);\n      applyNewKeys(state, target);\n      this.stop();\n\n      currentTweeen = tweeen(\n        0,\n        1,\n        percent => {\n          updateValues(state, source, target, percent);\n          if (typeof cb === 'function') {\n            cb(state as T & R);\n          }\n        },\n        Object.assign({}, options, {\n          end: () => {\n            if (typeof options.end === 'function') {\n              options.end(state as T & R);\n            }\n          }\n        })\n      );\n\n      return proxy as T & R & typeof instance;\n    }\n  };\n\n  const proxy = new Proxy<T & typeof instance>(state as any, {\n    get(obj, prop) {\n      if (obj.hasOwnProperty(prop)) {\n        return (obj as any)[prop as string];\n      }\n\n      return (instance as any)[prop];\n    }\n  });\n\n  return proxy;\n}\n","import transit from './src/index.ts';\n\nconst obj = document.getElementById('obj');\nconst jsonInput = document.getElementById('json');\nconst colorsInput = document.getElementById('colors');\nconst colorsSubmit = document.getElementById('colorsSubmit');\nconst resultInput = document.getElementById('result');\nconst gradient = document.getElementById('grad');\n\nconst applyStyle = style => {\n  obj.style.transform = `translate(${style.left}px, 40px) scale(${\n    style.scale\n  })`;\n  obj.style.color = style.color || '#000';\n  obj.style.background = `linear-gradient(${style.bg1}, ${style.bg2})`;\n  obj.innerText = Math.round(style.count);\n  resultInput.value = JSON.stringify(style, undefined, 2);\n};\n\nconst initial = JSON.parse(jsonInput.value);\nconst blockStyle = transit(initial, applyStyle);\napplyStyle(initial);\nconsole.log(blockStyle);\n\nconst transitOptions = {\n  duration: 300,\n  fps: 60,\n  easing: t => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t)\n};\n\nlet prevValue = jsonInput.value;\njsonInput.addEventListener('keyup', () => {\n  if (prevValue !== jsonInput.value) {\n    blockStyle.to(JSON.parse(jsonInput.value), transitOptions);\n    prevValue = jsonInput.value;\n  }\n});\n\nfunction gradientDemo(colors) {\n  let curColor = -1;\n  let stopped = false;\n  const gradColors = transit(\n    { c1: colors[colors.length - 1], c2: colors[0] },\n    ({ c1, c2 }) => {\n      gradient.style.backgroundImage = `linear-gradient(${c1}, ${c2})`;\n    }\n  );\n\n  const updateColors = () => {\n    if (stopped) {\n      return;\n    }\n    curColor = (curColor + 1) % colors.length;\n    const nextColor = (curColor + 1) % colors.length;\n    gradColors.to(\n      {\n        c1: colors[curColor],\n        c2: colors[nextColor]\n      },\n      {\n        end: updateColors,\n        duration: 2000\n      }\n    );\n  };\n\n  updateColors();\n\n  return () => {\n    gradColors.stop();\n    stopped = true;\n  };\n}\n\nlet currGradientDemo = gradientDemo(\n  colorsInput.value\n    .trim()\n    .split('\\n')\n    .map(s => s.trim())\n);\n\ncolorsSubmit.addEventListener('click', () => {\n  if (currGradientDemo) {\n    currGradientDemo();\n  }\n  currGradientDemo = gradientDemo(\n    colorsInput.value\n      .trim()\n      .split('\\n')\n      .map(s => s.trim())\n  );\n});\n"]}